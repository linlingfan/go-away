# golang

## go基本知识
4. Channel
5. Bitmap

#### new() 与 make() 的区别
new(T) 和 make(T, args)  是Go语言内建函数，用来分配内存，但适用的类型不用。  
new(T) 会为了 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如 数组 、 结构体 等。  
make(T, args) 返回初始化之后的T类型的值，也不是指针 *T ，是经过初始化之后的T的引用。 make() 只适用于 slice 、 map 和 chennel 。  

#### GMP调度模型
   - GMP
#### GO的垃圾回收机制
#### golang逃逸分析
- 如何进行逃逸分析？
   - 在golang中，所有内存都是由runtime管理的，程序猿不需要关心具体变量分配在哪里，什么时候回收，但是编译器需要知道这一点，这样才能确定函数栈帧大小、哪些变量需要"new"在堆上，所以编译器需要进行`逃逸分析`。简单来说，`逃逸分析`决定了一个变量是分配在栈上还是分配在堆上。
   - golang逃逸分析最基本的原则是：`如果一个函数返回的是一个（局部）变量的地址，那么这个变量就发生逃逸`。
   - 在golang里面，变量分配在何处和是否使用new无关，意味着程序猿无法手动指定某个变量必须分配在栈上或者堆上(自己撸asm的当我没说)，所以我们需要通过一些方法来确定某个变量到底是分配在了栈上还是堆上。



### go并发编程


## 函数和方法

- 错误
    - 文件结尾错误（EOF）：o包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF
    -

- 函数值：在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。

    - 函数类型的零值是nil。调用值为nil的函数值会引起panic错误
    ```
    var f func(int) int
    f(3) // 此处f的值为nil, 会引起panic错误
    ```
    - 但是函数值之间是不可比较的，也不能用函数值作为map的key。

- 匿名函数
    - 警告：捕获迭代变量:
      使用go语句（第八章）或者defer语句（5.8节）会经常遇到此类问题。这不是go或defer本身导致的，而是因为它们都会等待循环结束后，再执行函数值。

    ```
	// 捕获迭代变量
	var rmdirs []func()
	dirs := []string{"1","2","3"}
	for i := 0; i < len(dirs)-1; i++ {
		//m:=dirs[i]
		println(dirs[i]) // OK
		//println(m) // OK
		rmdirs = append(rmdirs, func() {
			//println(m) // ok
			println(dirs[i]) // NOTE: incorrect!
		})
	}
	for _,v:=range rmdirs {
		v()
    }

  ```

- 可变参数：参数数量可变的函数称为可变参数函数。

- Deferred函数：
  - 一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反
- Recover捕获异常  

### 方法

- 不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。
- 在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。

- Nil也是一个合法的接收器类型

- 封装：
  - Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。
  - 
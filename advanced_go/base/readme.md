# 基础语言

### 数组：
-  一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如C语言的数组），而是一个完整的值。
  当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。
  为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。
   
- 数组是值传递，无法通过修改数组类型的参数返回结果。可以使用切片。
  
- 长度为0的数组在内存中并不占用空间。var a [0]int

### 字符串

- 一个字符串是一个不可改变的字节序列，字符串通常是用来包含人类可读的文本数据。
  和数组不同的是，字符串的元素不可修改，是一个只读的字节数组。
  

### 切面

- append本质是用于追加元素而不是扩展容量，扩展切片容量只是append的一个副作用。
- 切片高效操作的要点是要降低内存分配的次数，尽量保证append操作不会超出cap的容量，降低触发内存分配的次数和每次分配内存大小。

- 切片内存泄露：
  [https://books.studygolang.com/advanced-go-programming-book/ch1-basic/ch1-03-array-string-and-slice.html](https://books.studygolang.com/advanced-go-programming-book/ch1-basic/ch1-03-array-string-and-slice.html)
  - 切片操作并不会复制底层的数据。底层的数组会被保存在内存中，直到它不再被引用。但是有时候可能会因为一个小的内存引用而导致底层整个数组处于被使用的状态，这会延迟自动内存回收器对底层数组的回收。
    ``` 
    func FindPhoneNumber(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return regexp.MustCompile("[0-9]+").Find(b) // []byte指向保存整个文件的数组。因为切片引用了整个原始数组，导致自动垃圾回收器不能及时释放底层数组的空间。
}
    ```
    - 解决：数据复制到一个新的切片中。切断了对原始数据的依赖
  - 在删除切片元素时可能会遇到。假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致不能及时被自动垃圾回收器回收。
    - 解决：先将需要自动内存回收的元素设置为nil
  ```
  var a []*int{ ... }
  a[len(a)-1] = nil // GC回收最后一个元素内存
  a = a[:len(a)-1]  // 从切片删除最后一个元素
  
  ```

- 切片类型强制转换
